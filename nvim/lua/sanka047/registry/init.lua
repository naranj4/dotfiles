--------------------------------------------------------------------------------
-- Registry
--------------------------------------------------------------------------------
-- This module contains global state for autocmds, augroups, etc
local M = {}

M.log_level = vim.log.levels.ERROR

--------------------------------------------------------------------------------
-- Utils
--------------------------------------------------------------------------------
local function _create_title(namespace, event, key)
    return '[' .. namespace .. '] ' .. event .. ': ' .. key
end

local log = {}

log.debug = function (namespace, event, key, msg)
    if M.log_level > vim.log.levels.DEBUG then
        return
    end
    vim.notify(msg, vim.log.levels.DEBUG, { title = _create_title(namespace, event, key) })
end

log.info = function (namespace, event, key, msg)
    if M.log_level > vim.log.levels.INFO then
        return
    end
    vim.notify(msg, vim.log.levels.INFO, { title = _create_title(namespace, event, key) })
end

log.warn = function (namespace, event, key, msg)
    if M.log_level > vim.log.levels.WARN then
        return
    end
    vim.notify(msg, vim.log.levels.WARN, { title = _create_title(namespace, event, key) })
end

log.error = function (namespace, event, key, msg)
    if M.log_level > vim.log.levels.ERROR then
        return
    end
    vim.notify(msg, vim.log.levels.ERROR, { title = _create_title(namespace, event, key) })
end

--------------------------------------------------------------------------------
-- Data
--------------------------------------------------------------------------------
local d = require('sanka047.registry.data')

-- Always return an empty table if there is no existing entry on any of the tables
local _registry_mt = { __index = function (table, key) return {} end }

-- For example:
-- ```
--     M._registry = {
--         ['<namespace>##<event>'] = {
--             commands = {
--                 <key> = {
--                     autocmd_id = <number>,
--                     callback = <function>,
--                     condition = <function (metadata)>,
--                     is_complete = <function (metadata)>,
--                 },
--             },
--             augroup_id = <number>,
--         },
--     }
-- ```
M._registry = {}
setmetatable(M._registry, _registry_mt)

-- Map of augroup id to augroup metadata. For example:
-- ```
--     M._augroups = {
--         <id> = {
--             group = <AuGroup>,
--             namespace = <string>,
--             event = <string>,
--         },
--     }
-- ```
M._augroups = {}
setmetatable(M._augroups, _registry_mt)

-- Map of autocmd id to autocmd metadata. For example:
-- ```
--     M._autocmds = {
--         <id> = {
--             command = <AutoCmd>,
--             namespace = <string>,
--             event = <string>,
--             key = <string>,
--             num_successes = <number>,
--             num_executions = <number>,
--         },
--     }
-- ```
M._autocmds = {}
setmetatable(M._autocmds, _registry_mt)

local function generate_registry_pk(namespace, event)
    return namespace .. '##' .. event
end

local function add_augroup(namespace, event, group)
    M._augroups[group.id] = {
        group = group,
        namespace = namespace,
        event = event,
    }
end

local function remove_augroup(id)
    local group = M._augroups[id].group
    if group then
        group:remove()
    end

    M._augroups[id] = nil
end

local function add_autocmd(namespace, event, key, cmd)
    M._autocmds[cmd.id] = {
        command = cmd,
        namespace = namespace,
        event = event,
        key = key,
        num_successes = 0,
        num_executions = 0,
    }
end

local function remove_autocmd(id)
    local cmd = M._autocmds[id].command
    if cmd then
        cmd:remove()
    end

    M._autocmds[id] = nil
end

-- Fetch autocommand metadata for the passed autocommand id
--
-- @param id number: autocmd id generated by the vim API (must be managed by the registry)
-- @return table: autocommand metadata
function M.get_autocmd_metadata(id)
    local data = M._autocmds[id]

    return {
        namespace = data.namespace,
        event = data.event,
        key = data.key,
        num_successes = data.num_successes,
        num_executions = data.num_executions,
    }
end

-- Fetch registry metadata for the specified namespace, event and key
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param key string: arbitrary text that is unique for each autocmd under the namespace and event
-- @return table: registry entry
function M.get_registry_entry(namespace, event, key)
    local pk = generate_registry_pk(namespace, event)
    return vim.deepcopy(M._registry[pk].commands[key])
end

-- Fetch registry autocmd for the specified namespace, event and key.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param key string: arbitrary text that is unique for each autocmd under the namespace and event
-- @return number: autocmd id
function M.get_registry_autocmd_id(namespace, event, key)
    return M.get_registry_entry(namespace, event, key).autocmd_id
end

-- Fetch registry augroup for the specified namespace and event. If there is no existing metadata,
-- then return an empty metadata table.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @return number: augroup id
function M.get_registry_namespace_event_augroup_id(namespace, event)
    local pk = generate_registry_pk(namespace, event)
    return M._registry[pk].augroup_id
end

-- Fetch the number of active commands under the specified namespace and event. If there are no
-- existing commands, return 0
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @return number: number of commands
function M.get_registry_namespace_event_command_count(namespace, event)
    local pk = generate_registry_pk(namespace, event)
    return vim.tbl_count(M._registry[pk].commands)
end

-- Update autocmd metadata
--
-- @param id number: autocmd id generated by the vim API (must be managed by the registry)
-- @param is_success bool: whether or not the current execution succeeded
-- @return table: old autocommand metadata
local function update_autocmd_metadata(id, is_success)
    local old = vim.deepcopy(M._autocmds[id])

    -- this feels like this could result in some race conditions (probably okay in this context)
    M._autocmds[id].num_executions = M._autocmds[id].num_executions + 1
    if is_success then
        M._autocmds[id].num_successes = M._autocmds[id].num_successes + 1
    end

    return old
end

-- Update registry augroup for the specified namespace and event.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param augroup_id number: new augroup id
-- @return number: old augroup id
local function update_registry_namespace_event_augroup_id(namespace, event, augroup_id)
    local pk = generate_registry_pk(namespace, event)
    local old_id = M._registry[pk].augroup_id

    -- set default value to empty table
    local commands = {}
    setmetatable(commands, _registry_mt)

    -- initialize the new namespace and event
    M._registry[pk] = {
        commands = commands,
        augroup_id = augroup_id,
    }

    return old_id
end

-- Update registry autocmd for the specified namespace, event and key.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param key string: arbitrary text that is unique for each autocmd under the namespace and event
-- @param entry table: new autocmd entry
-- @return number: old autocmd id
local function update_registry_entry(namespace, event, key, entry)
    local old_id = M.get_registry_autocmd_id(namespace, event, key)

    -- initialize the new namespace and event
    local pk = generate_registry_pk(namespace, event)
    M._registry[pk].commands[key] = entry

    return old_id
end

local function create_callback(namespace, event, key, opts)
    return function (data)
        local metadata = vim.tbl_deep_extend('force', data, M.get_autocmd_metadata(data.id))

        local is_success = false
        if not opts.condition(metadata) then -- check user defined conditions
            log.debug(namespace, event, key, 'User specified condition failed. Skipping')
        elseif not pcall(opts.callback, metadata) then -- call user defined callback
            log.error(namespace, event, key, 'Autocmd callback failed to run.')
        else
            is_success = true
        end

        -- update metadata
        local old = update_autocmd_metadata(data.id, is_success)
        log.debug(namespace, event, key, 'Old autocmd metdata: ' .. vim.inspect(old))

        metadata = vim.tbl_deep_extend('force', data, M.get_autocmd_metadata(data.id))
        if opts.is_complete(metadata) then
            M.unregister(namespace, event, key)
        end
    end
end

local function create_autocmd(namespace, event, key, opts)
    -- create the autocommand
    local callback = create_callback(namespace, event, key, opts)
    local cmd_opts = {
        group = opts.group,
        pattern = opts.pattern,
        desc = opts.desc,
        callback = callback,
    }

    return d.AutoCmd.new(event, cmd_opts)
end

local function create_augroup(namespace, event)
    return d.AuGroup.new(generate_registry_pk(namespace, event))
end

-- Creates and registers and autocmd to the registry. An augroup will be created (if one doesn't
-- exist already) from the namespace and event.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param key string: arbitrary text that is unique for each autocmd under the namespace and event
-- @param opts table: options passed to create the autocmd
-- ```
--     {
--         callback = <function (metadata)>,
--         condition = <function (metadata)>,
--         is_complete = <function (metadata)>,
--     }
-- ```
--     - callback <function>: Required function that is executed when the autocmd is triggered
--     - condition <function (metadata)>: Optional function to define any additional conditional
--       logic necessary to limit autocmd execution. This function will be ignored if the autocmd is
--       triggered manually
--     - is_complete <function (metadata)>: Optional function to determine whether the autocmd has
--       fully completed execution and can be removed from the registry
--     - metadata <table>: Provided to the `condition` and `is_complete` function. It contains the
--       following information in addition to the default parameters provided to `callback`:
--       ```
--           {
--               ...
--               namespace = <string>,
--               event = <string>,
--               key = <string>,
--               num_successes = <number>,
--               num_executions = <number>,
--           }
--       ```
function M.register(namespace, event, key, opts)
    log.debug(namespace, event, key, 'Registration options: ' .. vim.inspect(opts))

    -- setup sane default opts to get the default autocmd behavior
    local default_opts = {
        condition = function () return true end, -- autocmds always run if the pattern matches
        is_complete = function () return false end, -- autocmds are permanent in registry
    }
    opts = vim.tbl_deep_extend('force', default_opts, opts)

    -- check that there is an existing entry for the namespace and event
    local group_id = M.get_registry_namespace_event_augroup_id(namespace, event)
    local group
    if not group_id then
        -- there is no existing group, so create one
        group = create_augroup(namespace, event)
        log.debug(namespace, event, key, 'Created a new augroup: ' .. vim.inspect(group))
        group_id = group.id

        -- update the registry with the new group
        add_augroup(namespace, event, group)
        update_registry_namespace_event_augroup_id(namespace, event, group_id)
    end

    local autocmd_id = M.get_registry_autocmd_id(namespace, event, key)
    if autocmd_id then
        -- unregister the existing autocmd and delete it to avoid orphan autocmds
        log.debug(namespace, event, key, 'Deleting existing autocmd.')
        remove_autocmd(autocmd_id)
    end

    -- create the new autocmd
    opts = vim.tbl_deep_extend('force', opts, { group = group_id })
    local autocmd = create_autocmd(namespace, event, key, opts)

    -- register the autocmd in the registry
    local entry = {
        autocmd_id = autocmd.id,
        callback = opts.callback,
        condition = opts.condition,
        is_complete = opts.is_complete,
    }
    log.debug(namespace, event, key, 'Registering new autocmd:\n' .. vim.inspect(entry))
    add_autocmd(namespace, event, key, autocmd)
    update_registry_entry(namespace, event, key, entry)
end

-- Unregister a command under the given namespace, event and key. If there are no more commands
-- under a namespace and event, remove the event from the registry and delete the respective
-- augroup.
--
-- NOTE: This does not have to be manually run. Autocmds will automatically trigger this function if
-- they have satisfied their `is_complete` function.
--
-- @param namespace string: arbitrary string used to group autocmds
-- @param event string: neovim event. See `:h event` for list of possible events
-- @param key string: arbitrary text that is unique for each autocmd under the namespace and event
function M.unregister(namespace, event, key)
    -- update the existing registry entry with an empty table
    local old_id = update_registry_entry(namespace, event, key, nil)
    remove_autocmd(old_id)

    -- if there are no longer any commands registered to the augroup, unregister that as well
    local cmd_count = M.get_registry_namespace_event_command_count(namespace, event)
    log.debug(namespace, event, key, 'Unregister: There are currently ' .. cmd_count .. ' commands')
    if cmd_count == 0 then
        old_id = M.get_registry_namespace_event_augroup_id(namespace, event)

        -- unregister augroup
        remove_augroup(old_id)
        update_registry_namespace_event_augroup_id(namespace, event, nil)
    end
end

return M
